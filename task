#!/bin/bash
#TASK - A CLI reminders and task management toolkit
#CLI reminder toolkit for alerts/terminal headers and more
#Written by Will Russell/Scotchman0
#patch update: 7/3/22
#DEVELOP BRANCH TO BECOME NEW FORK FOR JOB MANAGEMENT ON NODES + SHARED WORKLOAD MANAGEMENT

#################################################################################

# desired layout template:

# ++++++++++++++++++++++++++++
# JOBS ON THIS NODE
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~
# NAME               ETA                    GPU USE
# yolo training     7-2-22 1430               yes
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~


# desired use case:  task -n 'yolo training' --eta 40h --gpu 'yes'

######################~~VARIABLES~~##############################
TASKDIR=~/bin/task-testing/
TASKPATH=$TASKDIR/.task_list
COMPLETED=$TASKDIR/.completed_list


# new-user init:
if [ ! -f "$TASKPATH" ]; then
   setup
   auto_complete
   echo "establishing default setup and storing tasks in ${TASKPATH}"
   echo ""
   echo "try task -h for usage and syntax"
fi

####################################~~FUNCTION BLOCKS~~########################


setup() {
#run only if ~/.remindme.conf does not exist - see firstrun block
#define file locations and paths
mkdir ${TASKDIR}
touch ${TASKPATH}
echo "this software uses the package 'at' - please ensure it is installed/enabled to allow reminders"
}


#OLD SINGLE-USER CONFIG SETUP BLOCK [removed]
# auto_complete() {
#   # #would you like to enable tab completion?
# echo "would you like to have tasks added to your ~/.*shrc profile to print list when you start a new shell?"
# echo "y|N"
# read option
# case $option in
#   y|Y) clear
#     echo "echo ## REMINDERS ##" >> ~/.*shrc
#     echo "cat ~/.task_list" >> ~/.*shrc
#     echo "cat command added to your ~/.*shrc file to read contents from ~/.task_list"
#     ;;
#   n|N) clear
#     echo "no configuration changes made - tasks are managed in ~/.task_list"
#     ;;
#   *) echo "non y/n answer recieved, defaulting to no change"
#     ;;
# esac
#}


alert() {
	if [[ ETA == NONE ]]
  then
    #notify-send $REMINDER | at $ETA
    #wall $REMINDER | at $ETA
    sleep 1
    exit 0
  else
    #placement of custom 'T' task queue to keep things unified -- Note, select EITHER Wall echo or
    # notify-send from echo options below, there is currently only one atq value for jobs
    #echo "notify-send 'node job has completed: $REMINDER'" | at $ETA
    echo "wall 'node job has completed: $REMINDER' | tee >> $COMPLETED" | at -q T $ETA 
    AT_QUEUE=$(atq -q T | tail -n 1 | awk {'print $1'})
  fi
}

alert_remove(){
  echo "$ENTRY is going to be purged from atq"
  atrm ${ENTRY}
}

alert_remove_all (){
  #purge all atq -T entries
  for x in $(atq -q T | awk {'print $1'}); do atrm $x; done
}

#primary action block:
while test $# -gt -1; do #general while loop to lock behavior surrounding case options. 
  case "$1" in
    -n|--new) #new-task entry baseline (TESTING WITH FUNCTION BLOCK)
      shift
      #Default value setting of variables
      GPU="N"
      USER=$(whoami)
      # logical call set for 'task was submitted, and has a value after -n of length longer than 0'
        if test $# -gt 0; then
          #set the task as a value for use with AT
          REMINDER=$@
          echo "add estimated hours for alert on job completion as an integer, insert 0 for NONE"
          read SETTIME
          if [[ ${SETTIME} != 0 ]]
            then
              ETA=$(echo $(date -d +${SETTIME}hours +%H:%M))
              alert
            else
              ETA=NONE
              AT_QUEUE=""
          fi
          echo "Uses GPU? (Y/N)"
          read GPU
        echo "${USER} | $@ | $ETA | $AT_QUEUE | $GPU" >> ${TASKPATH}

        else
          "null"
        fi
      break
      ;;
    -h|help)
      shift
      echo "#######  task help #######"
      echo "command usage: $ task <option> <string>"
      echo "task -h|help: print this breif help"
      echo "task -n|--new: create new reminder entry --> $ task -n 'buy eggs'"
      echo "task -d|--delete: delete line entry by number... ex: 'task -d 3'"
      echo "task -C|--clear: purge all reminders from list"
      #echo "task -r|reminder: set a date or a timer for a task alert..."
      break
      ;;
    -d|--delete|--done) #delete line entry by number
      cat -n ${TASKPATH}
      echo "do you wish to delete task entry $@? Y|n - will also delete wall echo alert"
      read reply
      case $reply in
        y|Y) ## NEED TO INCLUDE A CHECK THAT IF ENTRY=0 THEN SKIP ALERT_REMOVE
          shift
          DLINE="$@"
          ENTRY=$(cat -n $TASKPATH | grep ${DLINE} | awk {'print $8'})
          sed -i "${DLINE}d" $TASKPATH
          echo "deleted!"
          alert_remove
          ;;
        n|N)
          echo "cancelled delete"
          exit 1
          ;;
        *)
          echo "non y/n answer provided, no change"
          exit 0
          ;;
        esac
        break
        ;;
    -C|--clear) # purge all reminders
       echo "do you wish to purge all task entries?"
       read reply
       case $reply in
         y|Y)
           shift
           echo "removing all reminders"
           rm $TASKPATH
           touch $TASKPATH
           alert_remove_all
           ;;
         n|N)
           echo "cancelled delete"
           exit 0
           ;;
         *)
           echo "non y/n answer provided, no change"
           exit 0
           ;;
         esac
         break
         ;;
    *) #no option default -- print all tasks on node + formatting for column alignment (print on 'task' --noopts)
        echo " ++++++++++++++++++++++++++++"
        echo "      JOBS ON THIS NODE"
        echo " =~=~=~=~=~=~=~=~=~=~=~=~=~=~"
        #echo "JOB USER TASK ETA ATQ GPU" | awk '{ printf "%-5s %-20s %-38s %-15s %-2s\n", $1, $2, $3, $4, $5}' #default
        #cat -n ${TASKPATH} | awk 'BEGIN { FS = "|" };{ printf "%-1s %-50s %-15s %-10s\n", $1, $2, $3, $4, $5}' #default
        echo "JOB USER TASK ETA ATQ GPU" | awk '{ printf "%-5s %-20s %-38s %-5s %-5s %-2s\n", $1, $2, $3, $4, $5, $6}' #test
        cat -n ${TASKPATH} | awk 'BEGIN { FS = "|" };{ printf "%-1s %-50s %-5s %-5s %-8s\n", $1, $2, $3, $4, $5, $6}' #test
        break
		;;
  esac
done
exit 0
   